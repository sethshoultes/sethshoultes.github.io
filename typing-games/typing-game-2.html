<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeRunner - Typing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .game-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a237e;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .game-header > div {
            font-size: 18px;
            font-weight: bold;
            padding: 0 20px;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .word-input {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .word-input input {
            padding: 10px 20px;
            font-size: 18px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            width: 200px;
            text-align: center;
            outline: none;
        }

        .word-input input.correct {
            background: rgba(76, 175, 80, 0.2);
        }

        .word-input input.error {
            background: rgba(244, 67, 54, 0.2);
        }

        .hidden {
            display: none !important;
        }

        .game-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(26, 35, 126, 0.95);
            z-index: 200;
        }

        .game-menu h1 {
            font-size: 48px;
            margin-bottom: 40px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        button {
            padding: 12px 30px;
            font-size: 18px;
            border: none;
            border-radius: 4px;
            background: #4a90e2;
            color: white;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
            min-width: 200px;
        }

        button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }
        .settings-content, .highscores-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            min-width: 300px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            color: white;
            font-size: 16px;
        }

        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .setting-item select {
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            background: white;
            cursor: pointer;
        }
        .settings-input {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #1a237e;
            font-size: 16px;
            width: 150px;
        }

        .settings-input:focus {
            outline: 2px solid #4a90e2;
            background: white;
        }

        /* Add validation styling */
        .settings-input.invalid {
            border: 2px solid #ff4444;
        }

        .highscores-content {
            min-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 20px 0;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .score-item:last-child {
            border-bottom: none;
        }

        .score-rank {
            font-weight: bold;
            color: #4a90e2;
        }
        .score-date {
            color: rgba(255, 255, 255, 0.7);
        }
        .score-rank {
            font-weight: bold;
            color: #4a90e2;
            width: 40px;
        }

        .score-value {
            font-size: 1.1em;
            font-weight: bold;
        }
        .score-player {
            font-weight: bold;
            color: #4a90e2;
            margin-right: 10px;
        }

        .score-item {
            display: grid;
            grid-template-columns: 50px 150px auto 100px;
            gap: 10px;
            align-items: center;
        }

        .stage-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 150;
        }

        .game-header {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            padding: 0 20px;
            background: linear-gradient(to right, #1a237e, #303f9f);
            height: 70px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-logo {
            width: 40px;
            height: 40px;
            background: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #1a237e;
        }

        .game-title {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }

        .header-center {
            display: flex;
            gap: 30px;
            font-size: 18px;
            color: white;
        }

        .header-right {
            display: flex;
            justify-content: flex-end;
            position: relative;
        }

        .menu-button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 15px;
            transition: background 0.2s;
            border-radius: 4px;
        }

        .menu-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .in-game-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .in-game-menu button {
            background: none;
            border: none;
            padding: 8px 20px;
            text-align: left;
            color: #1a237e;
            border-radius: 4px;
            min-width: 150px;
        }

        .in-game-menu button:hover {
            background: #f0f0f0;
        }
        .debug-indicator {
            display: none;
            background: rgba(255, 0, 0, 0.2);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 10px;
        }

        .debug-indicator.active {
            display: block;
        }
        .achievements-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: transform 0.2s;
        }

        .achievement-item.locked {
            opacity: 0.5;
        }

        .achievement-item:hover {
            transform: translateY(-2px);
        }

        .achievement-icon {
            font-size: 24px;
            margin-right: 15px;
        }

        .achievement-details {
            flex-grow: 1;
        }

        .achievement-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .achievement-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
        }

        .achievement-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            background: rgba(74, 144, 226, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease-out;
        }

        .achievement-toast.show {
            transform: translateX(0);
        }

        .achievement-toast .achievement-icon {
            font-size: 30px;
            margin-right: 15px;
        }

        .achievement-toast .achievement-content {
            color: white;
        }

        .achievement-toast .achievement-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
    </style>
</head>
<body>
    <div id="game-container">
        <div class="game-header">
            <div class="header-left">
                <div class="game-logo">T</div>
                <div class="game-title">TypeRunner</div>
            </div>
            <div class="header-center">
                <div>Score: <span id="score">0</span></div>
                <div>Time: <span id="timer">60</span>s</div>
                <div>Stage: <span id="stage">1</span></div>
            </div>
            <div class="header-right">
                <div class="debug-indicator" id="debug-indicator">DEBUG</div>
                <button id="menu-toggle" class="menu-button">☰</button>
                <div id="in-game-menu" class="in-game-menu hidden">
                    <button id="resume-game">Resume</button>
                    <button id="toggle-debug">Toggle Debug</button>
                    <button id="exit-to-menu">Exit to Menu</button>
                </div>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Word Input -->
        <div id="word-input" class="word-input hidden">
            <input type="text" id="word-input-field" autocomplete="off">
        </div>

        <!-- Game Menu -->
        <div id="game-menu" class="game-menu">
            <h1>TypeRunner - Typing Game</h1>
            <div class="menu-buttons">
                <button id="start-game">Start Game</button>
                <button id="high-scores">High Scores</button>
                <button id="settings">Settings</button>
            </div>
        </div>

        <div id="game-over" class="game-menu hidden">
            <h2>Game Over!</h2>
            <div class="final-score">Final Score: <span id="final-score">0</span></div>
            <div class="menu-buttons">
                <button id="restart-game">Play Again</button>
                <button id="return-menu">Main Menu</button>
            </div>
        </div>
        <!-- Settings Menu -->
        <div id="settings-menu" class="game-menu hidden">
            <h2>Settings</h2>
            <div class="settings-content">
                <div class="setting-item">
                    <label>Sound Effects</label>
                    <input type="checkbox" id="setting-sound" checked>
                </div>
                <div class="setting-item">
                    <label>Music</label>
                    <input type="checkbox" id="setting-music" checked>
                </div>
                <div class="setting-item">
                    <label>Particle Effects</label>
                    <input type="checkbox" id="setting-particles" checked>
                </div>
                <div class="setting-item">
                    <label>Difficulty</label>
                    <select id="setting-difficulty">
                        <option value="easy">Easy</option>
                        <option value="normal" selected>Normal</option>
                        <option value="hard">Hard</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>Debug Visualization</label>
                    <input type="checkbox" id="setting-debug">
                </div>
                <div class="setting-item">
                    <label>Player Name</label>
                    <input type="text" 
                           id="setting-player-name" 
                           class="settings-input" 
                           placeholder="Enter your name"
                           maxlength="15">
                </div>
            </div>
            <div class="menu-buttons">
                <button id="save-settings">Save Settings</button>
                <button id="close-settings">Back</button>
            </div>
        </div>

        <!-- High Scores Menu -->
        <div id="highscores-menu" class="game-menu hidden">
            <h2>High Scores</h2>
            <div id="highscores-list" class="highscores-content">
                <!-- Scores will be inserted here -->
            </div>
            <div class="menu-buttons">
                <button id="close-highscores">Back to Menu</button>
            </div>
        </div>

        <!-- Achievements Menu -->
        <div id="achievements-menu" class="game-menu hidden">
            <h2>Achievements</h2>
            <div id="achievement-list" class="achievements-content">
                <!-- Achievements will be dynamically inserted here -->
            </div>
            <div class="menu-buttons">
                <button id="close-achievements">Back to Menu</button>
            </div>
        </div>

        <!-- Achievement Toast Notification -->
        <div id="achievement-toast" class="achievement-toast hidden">
            <div class="achievement-icon">🏆</div>
            <div class="achievement-content">
                <div class="achievement-title">Achievement Unlocked!</div>
                <div id="achievement-name"></div>
            </div>
        </div>

    </div>

    <script>
        class Particle {
            /**
             * Particle constructor
             * @param {number} x - The x position of the particle.
             * @param {number} y - The y position of the particle.
             * @param {string} color - The color of the particle.
             * @param {Object} velocity - The velocity of the particle.
             * @param {number} [life=1] - The life of the particle.
             */
            constructor(x, y, color, velocity, life = 1) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocity = velocity;
                this.alpha = 1;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha = (this.life / this.maxLife) * 1;
                this.life -= 0.02;
                this.size *= 0.97;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Game {
            /**
             * Constructor for the Game class.
             * 
             * Initializes the game state, initializes the
             * SettingsManager, HighScoreManager, and WordCache.
             * 
             * It also initializes the canvas context, sets up
             * game state variables, and initializes the particle
             * system.
             * 
             * Additionally, it sets up event listeners for the
             * game and initializes the high scores system.
             */
            constructor() {
                // First initialize managers
                this.settings = new SettingsManager();
                this.highScores = new HighScoreManager();
                this.wordCache = new WordCache();
                this.achievements = new AchievementManager();

                // Then initialize core elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.debug = this.settings.getSetting('debug');

                // Game state
                this.words = [];
                this.score = 0;
                this.timeLeft = 60;
                this.isActive = false;
                this.currentWord = null;
                this.currentStage = 1;
                this.wordsPerStage = 10;
                this.wordsCompleted = 0;
                this.stageRequirements = {
                    1: { speed: 1, wordCount: 10 },
                    2: { speed: 1.5, wordCount: 15 },
                    3: { speed: 2, wordCount: 20 }
                };


                // Initialize particle system
                this.particles = new Set();
                this.particlePool = new ParticlePool(200);
                this.lastParticleSpawn = 0;
                this.particleSpawnDelay = 50;
                this.particlePool = new ParticlePool(200);
                
                // Constants
                this.headerHeight = 60;
                this.padding = 40;
                
                // Player position
                this.playerX = 0;
                this.playerY = 0;
                
                // Movement state
                this.movement = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };

                // Initialize player name display
                this.updatePlayerNameDisplay();
                this.updateDebugIndicator();

                // Initialize high scores system
                this.highScores = new HighScoreManager();
                const highScoresBtn = document.getElementById('high-scores');
                if (highScoresBtn) {
                    highScoresBtn.addEventListener('click', () => {
                        this.showHighScores();
                    });
                }
                this.settings = new SettingsManager();
                
                // Initialize debug state from settings
                this.debug = this.settings.getSetting('debug');

                // Word list
                this.wordList = [
                    'javascript', 'programming', 'computer', 'web', 'game',
                    'development', 'typing', 'practice', 'code', 'learn',
                    'software', 'design', 'interface', 'testing', 'debug'
                ];

                // Initialize systems
                this.initSystems();
                this.initEventListeners();
            }
            
            createParticles(x, y, type = 'movement') {
                if (!this.settings.getSetting('particles')) return;

                switch(type) {
                    case 'movement':
                        if (Date.now() - this.lastParticleSpawn > this.particleSpawnDelay) {
                            for (let i = 0; i < 2; i++) {
                                const velocity = {
                                    x: (Math.random() - 0.5) * 2,
                                    y: (Math.random() - 0.5) * 2
                                };
                                const particle = this.particlePool.acquire(x, y, 'rgba(255, 255, 255, 0.5)', velocity, 0.5);
                                if (particle) this.particles.add(particle);
                            }
                            this.lastParticleSpawn = Date.now();
                        }
                        break;

                    case 'wordComplete':
                        const colors = ['#4CAF50', '#2196F3', '#FFC107', '#E91E63'];
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            const speed = 2 + Math.random() * 2;
                            const velocity = {
                                x: Math.cos(angle) * speed,
                                y: Math.sin(angle) * speed
                            };
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            const particle = this.particlePool.acquire(x, y, color, velocity, 1);
                            if (particle) this.particles.add(particle);
                        }
                        break;

                    case 'typing':
                        for (let i = 0; i < 3; i++) {
                            const velocity = {
                                x: (Math.random() - 0.5) * 4,
                                y: -2 - Math.random() * 2
                            };
                            const particle = this.particlePool.acquire(x, y, '#4CAF50', velocity, 0.5);
                            if (particle) this.particles.add(particle);
                        }
                        break;
                }
            }

                showHighScores() {
                        document.getElementById('game-menu').classList.add('hidden');
                        const highScoresMenu = document.getElementById('highscores-menu');
                        highScoresMenu.classList.remove('hidden');
                        this.highScores.displayScores(); // Refresh the displayed scores
                    }
                /**
                 * Initializes the game systems.
                 * 
                 * @throws {Error} If the system initialization fails.
                 */
                initSystems() {
                    try {
                        // Initialize canvas
                        this.resizeCanvas();
                        
                        // Set initial player position
                        this.playerX = this.canvas.width / 2;
                        this.playerY = this.headerHeight + 60;

                        // Initialize managers
                        this.settings = new SettingsManager();
                        this.highScores = new HighScoreManager();

                        console.log('Systems initialized successfully');
                    } catch (error) {
                        console.error('Error initializing systems:', error);
                    }
                }

                updateDebugIndicator() {
                    const indicator = document.getElementById('debug-indicator');
                    if (indicator) {
                        if (this.debug) {
                            indicator.classList.add('active');
                        } else {
                            indicator.classList.remove('active');
                        }
                    }
                }

                /**
                 * Initializes the event listeners for the game.
                 * 
                 * @throws {Error} If an event listener initialization fails.
                 */
                initEventListeners() {
                    try {
                        // Window events
                        window.addEventListener('resize', () => this.resizeCanvas());

                        // Game controls
                        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                        // Settings buttons
                        document.getElementById('save-settings').addEventListener('click', () => this.saveSettings());
                        document.getElementById('close-settings').addEventListener('click', () => {
                            document.getElementById('settings-menu').classList.add('hidden');
                            document.getElementById('game-menu').classList.remove('hidden');
                        });
                        document.getElementById('menu-toggle').addEventListener('click', () => {
                            document.getElementById('in-game-menu').classList.toggle('hidden');
                        });

                        document.getElementById('resume-game').addEventListener('click', () => {
                            document.getElementById('in-game-menu').classList.add('hidden');
                        });

                        document.getElementById('exit-to-menu').addEventListener('click', () => {
                            this.isActive = false;
                            this.showMenu();
                            document.getElementById('in-game-menu').classList.add('hidden');
                        });

                        document.getElementById('toggle-debug').addEventListener('click', () => {
                            this.debug = !this.debug;
                            this.settings.updateSetting('debug', this.debug);
                            this.updateDebugIndicator();
                            document.getElementById('in-game-menu').classList.add('hidden');
                        });

                        // Menu buttons
                        const startBtn = document.getElementById('start-game');
                        const restartBtn = document.getElementById('restart-game');
                        const returnBtn = document.getElementById('return-menu');
                        const settingsBtn = document.getElementById('settings');
                        const highScoresBtn = document.getElementById('high-scores');

                        if (startBtn) startBtn.addEventListener('click', () => this.start());
                        if (restartBtn) restartBtn.addEventListener('click', () => this.start());
                        if (returnBtn) returnBtn.addEventListener('click', () => this.showMenu());
                        if (settingsBtn) settingsBtn.addEventListener('click', () => this.showSettings());
                        if (highScoresBtn) highScoresBtn.addEventListener('click', () => this.showHighScores());

                        // Word input
                        const wordInput = document.getElementById('word-input-field');
                        if (wordInput) {
                            wordInput.addEventListener('input', () => this.checkWord());
                        }

                        console.log('Event listeners initialized successfully');
                    } catch (error) {
                        console.error('Error initializing event listeners:', error);
                    }
                }


            showHighScores() {
                const highScoresMenu = document.getElementById('highscores-menu');
                const gameMenu = document.getElementById('game-menu');
                
                if (highScoresMenu && gameMenu) {
                    this.highScores.displayScores();
                    gameMenu.classList.add('hidden');
                    highScoresMenu.classList.remove('hidden');
                }
            }

            init() {
                // Set canvas size
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Initialize player position below header
                this.playerX = this.canvas.width / 2;
                this.playerY = this.headerHeight + 60;

                // Set up event listeners
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Menu buttons
                document.getElementById('start-game').addEventListener('click', () => this.start());
                document.getElementById('restart-game').addEventListener('click', () => this.start());
                document.getElementById('return-menu').addEventListener('click', () => this.showMenu());
                
                // Word input
                document.getElementById('word-input-field').addEventListener('input', () => this.checkWord());
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            start() {
                this.score = 0;
                this.timeLeft = 60;
                this.isActive = true;
                this.words = [];
                this.currentWord = null;
                this.updateDebugIndicator();
                this.updatePlayerNameDisplay();
                
                // Reset player position
                this.playerX = this.canvas.width / 2;
                this.playerY = this.headerHeight + 60;
                
                // Hide menus
                document.getElementById('game-menu').classList.add('hidden');
                document.getElementById('game-over').classList.add('hidden');
                
                // Update UI
                document.getElementById('score').textContent = '0';
                document.getElementById('timer').textContent = '60';
                
                // Add initial words
                for (let i = 0; i < 5; i++) {
                    this.addWord();
                }

                // Start game loop and timer
                this.gameLoop();
                this.startTimer();
            }

            // Modify addWord to have more controlled initial velocities
            addWord() {
                const baseSpeed = 1; // Base speed for word movement
                const angle = Math.random() * Math.PI * 2; // Random angle in radians
                
                const word = {
                    text: this.wordList[Math.floor(Math.random() * this.wordList.length)],
                    x: this.canvas.width / 2, // Start from center
                    y: this.canvas.height / 2,
                    vx: Math.cos(angle) * baseSpeed,
                    vy: Math.sin(angle) * baseSpeed
                };
                this.words.push(word);
            }
            
            /**
             * Game loop function. This function is responsible for updating and drawing the game
             * state, including the player, words, and particles. It is called repeatedly by
             * requestAnimationFrame.
             * 
             * Updates the player's position based on the movement flags, and checks for collisions
             * with the words. If a collision is detected, the word is frozen in place and the
             * player is given the opportunity to type the word. If the player successfully types
             * the word, the word is removed from the game state and the player is awarded points.
             * 
             * Also draws the player, words, and particles to the canvas.
             */
            gameLoop() {
                if (!this.isActive) return;

                // Use RAF timestamp for timing
                const currentTime = performance.now();
                if (!this.lastFrame) this.lastFrame = currentTime;
                const delta = (currentTime - this.lastFrame) / 16.67; // Normalize to 60fps
                this.lastFrame = currentTime;

                // Clear only the changed regions
                const dirtyRegions = new Set();
                // Add player's old and new positions to dirty regions
                dirtyRegions.add({
                    x: this.playerX - 25,
                    y: this.playerY - 25,
                    width: 50,
                    height: 50
                });


                // Clear canvas with gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1e3a8a');
                gradient.addColorStop(1, '#2563eb');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Update player position
                if (!this.currentWord) {
                    const moveSpeed = 5 * delta;
                    if (this.movement.w) this.playerY -= moveSpeed;
                    if (this.movement.s) this.playerY += moveSpeed;
                    if (this.movement.a) this.playerX -= moveSpeed;
                    if (this.movement.d) this.playerX += moveSpeed;

                    // Keep player in bounds and below header
                    this.playerX = Math.max(this.padding, Math.min(this.canvas.width - this.padding, this.playerX));
                    this.playerY = Math.max(this.headerHeight + this.padding, Math.min(this.canvas.height - this.padding, this.playerY));
                }

                // Draw player
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(this.playerX, this.playerY, 20, 0, Math.PI * 2);
                this.ctx.fill();

                for (const particle of this.particles) {
                    particle.update();
                    particle.draw(this.ctx);
                    if (particle.life <= 0) {
                        this.particles.delete(particle);
                        this.particlePool.release(particle);
                    }
                }

                // Create movement particles
                if (this.movement.w || this.movement.a || this.movement.s || this.movement.d) {
                    this.createParticles(this.playerX, this.playerY, 'movement');
                }

                // Update and draw words
                this.words.forEach(word => {
                    // Calculate word boundaries including text width
                    const wordWidth = this.ctx.measureText(word.text).width;
                    const effectivePadding = 20; // Smaller padding for tighter bounds
                    // Only move the word if it's not the current word being typed
                    if (word !== this.currentWord) {
                            // Update position
                            word.x += word.vx;
                            word.y += word.vy;
                            
                            // Boundary checks with proper bouncing
                            if (word.x <= effectivePadding) {
                                word.x = effectivePadding;
                                word.vx = Math.abs(word.vx); // Ensure positive velocity
                            }
                            if (word.x + wordWidth >= this.canvas.width - effectivePadding) {
                                word.x = this.canvas.width - wordWidth - effectivePadding;
                                word.vx = -Math.abs(word.vx); // Ensure negative velocity
                            }
                            
                            if (word.y <= this.headerHeight + effectivePadding) {
                                word.y = this.headerHeight + effectivePadding;
                                word.vy = Math.abs(word.vy); // Ensure positive velocity
                            }
                            if (word.y >= this.canvas.height - effectivePadding) {
                                word.y = this.canvas.height - effectivePadding;
                                word.vy = -Math.abs(word.vy); // Ensure negative velocity
                            }
                    }
                    

                    // Add movement to words
                    if (!word.vx) word.vx = (Math.random() - 0.5) * 2; // Random horizontal velocity
                    if (!word.vy) word.vy = (Math.random() - 0.5) * 2; // Random vertical velocity
                    
                    // Update word position
                    word.x += word.vx;
                    word.y += word.vy;

                    // Only move the word if it's active (not being typed)
                    if (word.isActive) {
                        word.x += word.vx;
                        word.y += word.vy;
                        
                        // Bounce off walls
                        if (word.x <= this.padding || word.x >= this.canvas.width - this.padding) word.vx *= -1;
                        if (word.y <= this.headerHeight + this.padding || word.y >= this.canvas.height - this.padding) word.vy *= -1;
                    }

                    // Draw word with different style if it's being typed
                    this.ctx.font = '20px Arial';
                    this.ctx.fillStyle = word === this.currentWord ? '#4CAF50' : 'white';
                    this.ctx.fillText(word.text, word.x, word.y);
                    
                    // Bounce off walls
                    if (word.x <= this.padding || word.x >= this.canvas.width - this.padding) word.vx *= -1;
                    if (word.y <= this.headerHeight + this.padding || word.y >= this.canvas.height - this.padding) word.vy *= -1;

                    // Only draw debug visualization if debug is enabled
                    if (this.debug) {
                        const wordWidth = this.ctx.measureText(word.text).width;
                        const wordHeight = 20;
                        const margin = 20;
                        
                        // Draw word collision box
                        this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(
                            word.x - margin,
                            word.y - wordHeight - margin,
                            wordWidth + (margin * 2),
                            wordHeight + (margin * 2)
                        );
                    }

                    // Collision detection
                    if (!this.currentWord) {
                        const playerRadius = 20; // Player circle radius
                        const wordBounds = {
                            left: word.x - effectivePadding,
                            right: word.x + wordWidth + effectivePadding,
                            top: word.y - 20 - effectivePadding,
                            bottom: word.y + effectivePadding
                        };

                        // Improved collision detection
                        if (this.playerX + playerRadius > wordBounds.left && 
                            this.playerX - playerRadius < wordBounds.right && 
                            this.playerY + playerRadius > wordBounds.top && 
                            this.playerY - playerRadius < wordBounds.bottom) {
                            
                            this.currentWord = word;
                            document.getElementById('word-input').classList.remove('hidden');
                            document.getElementById('word-input-field').value = '';
                            document.getElementById('word-input-field').focus();
                        }
                    }
                });

                // Draw player debug visualization if debug is enabled
                if (this.debug) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(this.playerX, this.playerY, 20, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                requestAnimationFrame(() => this.gameLoop());
            }

            // Event handlers
            handleKeyDown(e) {
                // Check if any input element is focused
                const activeElement = document.activeElement;
                const isInputFocused = activeElement.tagName === 'INPUT' || 
                                    activeElement.tagName === 'TEXTAREA';
                
                if (!isInputFocused && !this.currentWord && e.key.toLowerCase() in this.movement) {
                    e.preventDefault();
                    this.movement[e.key.toLowerCase()] = true;
                }
            }

            handleKeyUp(e) {
                if (e.key.toLowerCase() in this.movement) {
                    e.preventDefault();
                    this.movement[e.key.toLowerCase()] = false;
                }
            }

            checkWord() {
                if (!this.currentWord) return;

                const input = document.getElementById('word-input-field');
                const inputWord = input.value.toLowerCase();
                const targetWord = this.currentWord.text.toLowerCase();

                // Visual feedback
                if (targetWord.startsWith(inputWord)) {
                    input.classList.add('correct');
                    input.classList.remove('error');
                    // Add typing particles at word position
                    this.createParticles(this.currentWord.x, this.currentWord.y, 'typing');
                } else {
                    input.classList.add('error');
                    input.classList.remove('correct');
                }

                if (inputWord === targetWord) {
                    this.wordsCompleted++;

                    // Check word completion achievement
                    this.achievements.checkAchievement('wordComplete');
                    // Check word speed achievement
                    const typingTime = (Date.now() - this.wordStartTime) / 1000;
                    this.achievements.checkAchievement('wordSpeed', typingTime);
                                        
                    // Check for stage completion
                    if (this.wordsCompleted >= this.stageRequirements[this.currentStage].wordCount) {
                        this.advanceStage();
                    }

                    // Create completion particles at word position
                    this.createParticles(this.currentWord.x, this.currentWord.y, 'wordComplete');
                    
                    this.score += 10;
                    document.getElementById('score').textContent = this.score;
                    this.achievements.checkAchievement('score', this.score);
                    
                    this.words = this.words.filter(w => w !== this.currentWord);
                    this.addWord();
                    
                    // Remove the completed word
                    this.words = this.words.filter(w => w !== this.currentWord);
                    this.currentWord = null;
                    input.value = '';
                    input.classList.remove('correct', 'error');
                    document.getElementById('word-input').classList.add('hidden');
                }
            }

            /**
             * Advance to the next stage.
             * 
             * This function increments the current stage index, resets the word counter, and updates the stage indicator in the UI. It also displays a brief animation to indicate the transition. Finally, it increases the difficulty by calling `updateStageParameters`.
             */
            advanceStage() {
                this.currentStage++;
                this.wordsCompleted = 0;
                this.achievements.checkAchievement('stage', this.currentStage);
                
                // Update UI
                document.getElementById('stage').textContent = this.currentStage;
                
                // Show stage transition
                const stageIndicator = document.createElement('div');
                stageIndicator.className = 'stage-indicator';
                stageIndicator.textContent = `Stage ${this.currentStage}`;
                document.body.appendChild(stageIndicator);
                
                // Animate and remove
                setTimeout(() => {
                    stageIndicator.style.opacity = '1';
                    setTimeout(() => {
                        stageIndicator.style.opacity = '0';
                        setTimeout(() => stageIndicator.remove(), 300);
                    }, 1000);
                }, 0);
                
                // Increase difficulty
                this.updateStageParameters();
            }

            /**
             * Update the parameters of the current stage.
             * 
             * This function fetches the parameters for the current stage from `this.stageRequirements`, or uses default values if none are provided. It then updates the movement speed of all words (`word.vx` and `word.vy`) to the new value.
             */
            updateStageParameters() {
                const stage = this.stageRequirements[this.currentStage] || {
                    speed: this.currentStage * 0.5,
                    wordCount: 10 + (this.currentStage * 5)
                };
                
                // Update word movement speed
                this.words.forEach(word => {
                    word.vx *= stage.speed;
                    word.vy *= stage.speed;
                });
            }

            startTimer() {
                const timerInterval = setInterval(() => {
                    this.timeLeft--;
                    document.getElementById('timer').textContent = this.timeLeft;
                    
                    if (this.timeLeft <= 0) {
                        clearInterval(timerInterval);
                        this.endGame();
                    }
                }, 1000);
            }

            endGame() {
                this.isActive = false;
                
                // Save score
                if (this.score > 0) {
                    this.highScores.saveScore(this.score);
                }
                
                // Update UI
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('game-over').classList.remove('hidden');
            }

            showMenu() {
                document.getElementById('game-over').classList.add('hidden');
                document.getElementById('game-menu').classList.remove('hidden');
            }

            initializeUIHandlers() {
                // Settings handlers
                document.getElementById('settings').addEventListener('click', () => this.showSettings());
                document.getElementById('save-settings').addEventListener('click', () => this.saveSettings());
                document.getElementById('close-settings').addEventListener('click', () => {
                    document.getElementById('settings-menu').classList.add('hidden');
                    document.getElementById('game-menu').classList.remove('hidden');
                });

                // High scores handlers
                document.getElementById('high-scores').addEventListener('click', () => {
                    this.highScores.displayScores();
                    document.getElementById('game-menu').classList.add('hidden');
                    document.getElementById('highscores-menu').classList.remove('hidden');
                });
                document.getElementById('close-highscores').addEventListener('click', () => {
                    document.getElementById('highscores-menu').classList.add('hidden');
                    document.getElementById('game-menu').classList.remove('hidden');
                });
            }

            showSettings() {
                const settingsMenu = document.getElementById('settings-menu');
                const gameMenu = document.getElementById('game-menu');
                
                document.getElementById('setting-sound').checked = this.settings.getSetting('sound');
                document.getElementById('setting-music').checked = this.settings.getSetting('music');
                document.getElementById('setting-particles').checked = this.settings.getSetting('particles');
                document.getElementById('setting-difficulty').value = this.settings.getSetting('difficulty');
                document.getElementById('setting-debug').checked = this.settings.getSetting('debug');
                document.getElementById('setting-player-name').value = this.settings.getSetting('playerName');
                
                document.getElementById('game-menu').classList.add('hidden');
                document.getElementById('settings-menu').classList.remove('hidden');

            }

            /**
             * Saves all current settings to local storage and updates the UI to reflect the changes.
             */
             saveSettings() {
                const playerNameInput = document.getElementById('setting-player-name');
                const playerName = playerNameInput.value.trim();
                // Validate player name
                if (playerName.length < 1) {
                    playerNameInput.classList.add('invalid');
                    return; // Don't save settings if name is invalid
                }
                playerNameInput.classList.remove('invalid');
                const newSettings = {
                    sound: document.getElementById('setting-sound').checked,
                    music: document.getElementById('setting-music').checked,
                    particles: document.getElementById('setting-particles').checked,
                    difficulty: document.getElementById('setting-difficulty').value,
                    debug: document.getElementById('setting-debug').checked,
                    playerName: playerName
                };

                // Update all settings
                Object.entries(newSettings).forEach(([key, value]) => {
                    this.settings.updateSetting(key, value);
                });

                // Update debug state
                this.debug = newSettings.debug;
                this.updateDebugIndicator();

                // Update player name
                this.updatePlayerNameDisplay();

                // Apply settings
                document.getElementById('settings-menu').classList.add('hidden');
                document.getElementById('game-menu').classList.remove('hidden');
            }

            updatePlayerNameDisplay() {
                try {
                    const playerName = this.settings.getSetting('playerName');
                    const titleElement = document.querySelector('.game-title');
                    if (titleElement) {
                        titleElement.textContent = `TypeRunner - ${playerName}`;
                    }
                } catch (error) {
                    console.error('Error updating player name display:', error);
                }
            }

            applySettings() {
                // Apply sound settings
                if (this.settings.getSetting('sound')) {
                    // Enable sound effects
                } else {
                    // Disable sound effects
                }
                
                // Apply music settings
                if (this.settings.getSetting('music')) {
                    // Enable music
                } else {
                    // Disable music
                }
                
                // Apply particle settings
                if (this.settings.getSetting('particles')) {
                    // Enable particles
                } else {
                    // Disable particles
                }
                
                // Apply difficulty settings
                const difficulty = this.settings.getSetting('difficulty');
                switch(difficulty) {
                    case 'easy':
                        this.wordList = this.easyWords;
                        break;
                    case 'normal':
                        this.wordList = this.normalWords;
                        break;
                    case 'hard':
                        this.wordList = this.hardWords;
                        break;
                }
            }
        }

        class SettingsManager {
            constructor() {
                this.settings = this.loadSettings();
            }

            loadSettings() {
                const defaultSettings = {
                    sound: true,
                    music: true,
                    particles: true,
                    difficulty: 'normal',
                    debug: false,
                    playerName: 'Player' // Default player name
                };

                try {
                    const saved = localStorage.getItem('gameSettings');
                    return saved ? JSON.parse(saved) : defaultSettings;
                } catch (error) {
                    console.error('Error loading settings:', error);
                    return defaultSettings;
                }
            }

            getSetting(key) {
                return this.settings[key];
            }
            sanitizePlayerName(name) {
                return name
                    .replace(/[<>]/g, '') // Remove potential HTML
                    .replace(/[^\w\s-]/g, '') // Allow only word chars, spaces, and hyphens
                    .trim()
                    .slice(0, 15); // Limit length
            }


            updateSetting(key, value) {
                this.settings[key] = value;
                try {
                    localStorage.setItem('gameSettings', JSON.stringify(this.settings));
                    console.log(`Setting updated: ${key} = ${value}`);
                } catch (error) {
                    console.error('Error saving settings:', error);
                }
            }
            saveSettings() {
                try {
                    localStorage.setItem('gameSettings', JSON.stringify(this.settings));
                    return true;
                } catch (error) {
                    console.error('Error saving settings:', error);
                    return false;
                }
            }
        }

        class HighScoreManager {
            constructor() {
                this.scores = this.loadScores();
                this.initializeListeners();
            }

            initializeListeners() {
                const closeButton = document.getElementById('close-highscores');
                if (closeButton) {
                    closeButton.addEventListener('click', () => this.closeHighScores());
                }
            }

            loadScores() {
                try {
                    const saved = localStorage.getItem('highScores');
                    console.log('Loaded scores from storage:', saved);
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.error('Error loading high scores:', error);
                    return [];
                }
            }

            saveScore(score) {
                try {
                    const settings = new SettingsManager();
                    const playerName = settings.getSetting('playerName');
                    this.scores.push({
                        playerName: playerName,
                        score: score,
                        date: new Date().toISOString(),
                        stage: 1
                    });

                    // Sort scores in descending order and keep top 10
                    this.scores.sort((a, b) => b.score - a.score);
                    this.scores = this.scores.slice(0, 10);

                    localStorage.setItem('highScores', JSON.stringify(this.scores));
                } catch (error) {
                    console.error('Error saving score:', error);
                }
            }

            displayScores() {
                const scoresList = document.getElementById('highscores-list');
                if (!scoresList) return;

                if (!this.scores || this.scores.length === 0) {
                    scoresList.innerHTML = '<div class="score-item">No scores yet!</div>';
                    return;
                }

                scoresList.innerHTML = this.scores
                    .map((score, index) => `
                        <div class="score-item">
                            <span class="score-rank">#${index + 1}</span>
                            <span class="score-player">${score.playerName}</span>
                            <span class="score-value">${score.score} points</span>
                            <span class="score-date">${new Date(score.date).toLocaleDateString()}</span>
                        </div>
                    `)
                    .join('');
            }

            closeHighScores() {
                document.getElementById('highscores-menu').classList.add('hidden');
                document.getElementById('game-menu').classList.remove('hidden');
            }
        }

        class WordPositionManager {
            /**
             * Initializes the WordPositionManager.
             * @param {number} stage - The current game stage.
             * @param {number} canvasWidth - The width of the game canvas.
             * @param {number} canvasHeight - The height of the game canvas.
             */
            constructor(stage, canvasWidth, canvasHeight) {
                this.stage = stage;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.centerZone = 0.4; // 40% of screen width for center zone
            }

            getWordPosition() {
                const margin = 100;
                let x, y;
                
                if (this.stage <= 2) {
                    // Early stages: words appear near center
                    x = (this.canvasWidth * (0.5 - this.centerZone/2)) + 
                        (Math.random() * this.canvasWidth * this.centerZone);
                } else {
                    // Later stages: words appear closer to edges
                    const side = Math.random() > 0.5;
                    x = side ? 
                        margin + (Math.random() * this.canvasWidth * 0.3) :
                        this.canvasWidth * 0.7 + (Math.random() * (this.canvasWidth * 0.3 - margin));
                }
                
                y = margin + Math.random() * (this.canvasHeight - margin * 2);
                return {x, y};
            }
        }

        class ParticlePool {
            /**
             * Creates a new particle pool.
             * @param {number} [size=200] - The number of particles in the pool.
             */
            constructor(size = 200) {
                this.pool = Array(size).fill(null).map(() => new Particle(0, 0, 'white', {x:0, y:0}));
                this.active = new Set();
            }
            
            acquire(x, y, color, velocity, life = 1) {
                const particle = this.pool.find(p => !this.active.has(p));
                if (particle) {
                    particle.x = x;
                    particle.y = y;
                    particle.color = color;
                    particle.velocity = velocity;
                    particle.life = life;
                    particle.maxLife = life;
                    particle.alpha = 1;
                    particle.size = Math.random() * 3 + 2;
                    this.active.add(particle);
                    return particle;
                }
                return null;
            }
            
            release(particle) {
                this.active.delete(particle);
            }
        }

        class WordCache {
            /**
             * Create a new WordCache instance.
             *
             * The cache will store up to `maxSize` entries, mapping a word's text to its
             * measured width (in pixels) when rendered with the given rendering context.
             *
             * @param {number} [maxSize=100] - The maximum number of entries to store in
             *                                  the cache.
             */
            constructor() {
                this.cache = new Map();
                this.maxSize = 100;
            }

            getWord(text, ctx) {
                if (!this.cache.has(text)) {
                    const metrics = ctx.measureText(text);
                    this.cache.set(text, {
                        width: metrics.width,
                        height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
                    });
                    
                    // Prevent cache from growing too large
                    if (this.cache.size > this.maxSize) {
                        const firstKey = this.cache.keys().next().value;
                        this.cache.delete(firstKey);
                    }
                }
                return this.cache.get(text);
            }
        }
        class AchievementManager {
            /**
             * Initialize the AchievementManager.
             *
             * The constructor initializes the internal state of the manager, which
             * includes the list of achievements and their current state. It also loads
             * the achievements from local storage and initializes the UI elements.
             */
            constructor() {
                this.achievements = {
                    firstWord: {
                        id: 'firstWord',
                        icon: '🎯',
                        name: 'First Word',
                        description: 'Type your first word',
                        unlocked: false
                    },
                    speedster: {
                        id: 'speedster',
                        icon: '⚡',
                        name: 'Speedster',
                        description: 'Type a word in under 1 second',
                        unlocked: false
                    },
                    highScore100: {
                        id: 'highScore100',
                        icon: '💯',
                        name: 'Century',
                        description: 'Reach 100 points',
                        unlocked: false
                    },
                    stage3: {
                        id: 'stage3',
                        icon: '🏃',
                        name: 'Marathon Runner',
                        description: 'Reach Stage 3',
                        unlocked: false
                    },
                    wordMaster: {
                        id: 'wordMaster',
                        icon: '📚',
                        name: 'Word Master',
                        description: 'Type 50 words total',
                        unlocked: false,
                        progress: 0,
                        required: 50
                    }
                };
                
                this.loadAchievements();
                this.initializeUI();
            }

            loadAchievements() {
                const saved = localStorage.getItem('achievements');
                if (saved) {
                    const savedAchievements = JSON.parse(saved);
                    // Merge saved state with default achievements
                    Object.keys(this.achievements).forEach(key => {
                        if (savedAchievements[key]) {
                            this.achievements[key].unlocked = savedAchievements[key].unlocked;
                            if (savedAchievements[key].progress !== undefined) {
                                this.achievements[key].progress = savedAchievements[key].progress;
                            }
                        }
                    });
                }
            }

            saveAchievements() {
                localStorage.setItem('achievements', JSON.stringify(this.achievements));
            }

            checkAchievement(type, value) {
                switch(type) {
                    case 'wordComplete':
                        if (!this.achievements.firstWord.unlocked) {
                            this.unlockAchievement('firstWord');
                        }
                        if (this.achievements.wordMaster.progress < this.achievements.wordMaster.required) {
                            this.achievements.wordMaster.progress++;
                            if (this.achievements.wordMaster.progress >= this.achievements.wordMaster.required) {
                                this.unlockAchievement('wordMaster');
                            }
                        }
                        break;
                    case 'wordSpeed':
                        if (!this.achievements.speedster.unlocked && value < 1) {
                            this.unlockAchievement('speedster');
                        }
                        break;
                    case 'score':
                        if (!this.achievements.highScore100.unlocked && value >= 100) {
                            this.unlockAchievement('highScore100');
                        }
                        break;
                    case 'stage':
                        if (!this.achievements.stage3.unlocked && value >= 3) {
                            this.unlockAchievement('stage3');
                        }
                        break;
                }
                this.saveAchievements();
            }

            unlockAchievement(id) {
                if (!this.achievements[id].unlocked) {
                    this.achievements[id].unlocked = true;
                    this.showToast(this.achievements[id]);
                    this.updateAchievementDisplay();
                }
            }

            showToast(achievement) {
                const toast = document.getElementById('achievement-toast');
                const name = document.getElementById('achievement-name');
                
                name.textContent = achievement.name;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            initializeUI() {
                const closeBtn = document.getElementById('close-achievements');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('achievements-menu').classList.add('hidden');
                        document.getElementById('game-menu').classList.remove('hidden');
                    });
                }
                
                // Add achievements button to main menu
                const menuButtons = document.querySelector('.menu-buttons');
                if (menuButtons) {
                    const achievementsButton = document.createElement('button');
                    achievementsButton.id = 'show-achievements';
                    achievementsButton.textContent = 'Achievements';
                    achievementsButton.addEventListener('click', () => this.showAchievements());
                    menuButtons.insertBefore(achievementsButton, menuButtons.lastElementChild);
                }
                
                this.updateAchievementDisplay();
            }

            showAchievements() {
                document.getElementById('game-menu').classList.add('hidden');
                document.getElementById('achievements-menu').classList.remove('hidden');
            }

            updateAchievementDisplay() {
                const container = document.getElementById('achievement-list');
                if (!container) return;

                container.innerHTML = Object.values(this.achievements)
                    .map(achievement => `
                        <div class="achievement-item ${achievement.unlocked ? 'unlocked' : 'locked'}">
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div class="achievement-details">
                                <div class="achievement-name">${achievement.name}</div>
                                <div class="achievement-description">${achievement.description}</div>
                                ${achievement.progress !== undefined ? 
                                    `<div class="achievement-progress">Progress: ${achievement.progress}/${achievement.required}</div>` 
                                    : ''}
                            </div>
                        </div>
                    `).join('');
            }
        }

        // Initialize game when the page is fully loaded
        window.addEventListener('load', () => {
            try {
                console.log('Initializing game...');
                const game = new Game();
                // Store game instance globally for debugging
                window.gameInstance = game;
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Failed to initialize game:', error);
                // Show error to user
                const container = document.getElementById('game-container');
                if (container) {
                    container.innerHTML += `
                        <div class="error-message" style="color: white; padding: 20px;">
                            Error initializing game. Please refresh the page.
                            <br>
                            Error details: ${error.message}
                        </div>
                    `;
                }
            }
        });


    </script>
</body>
</html>